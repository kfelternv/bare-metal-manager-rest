/*
NVIDIA Bare Metal Manager REST API

NVIDIA Bare Metal Manager REST API allows users to create and manage resources e.g. VPC, Subnets, Instances across all connected NVIDIA Bare Metal Manager datacenters, also referred to as Sites.

API version: 1.0.4
Contact: carbide-dev@exchange.nvidia.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package standard

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// TrayAPIService TrayAPI service
type TrayAPIService service

type ApiGetAllTrayRequest struct {
	ctx context.Context
	ApiService *TrayAPIService
	siteId *string
	org string
	rackId *string
	rackName *string
	type_ *string
	componentId *string
	id *string
	pageNumber *int32
	pageSize *int32
	orderBy *string
}

// ID of the Site to retrieve Trays from
func (r ApiGetAllTrayRequest) SiteId(siteId string) ApiGetAllTrayRequest {
	r.siteId = &siteId
	return r
}

// Filter by Rack ID
func (r ApiGetAllTrayRequest) RackId(rackId string) ApiGetAllTrayRequest {
	r.rackId = &rackId
	return r
}

// Filter by Rack name
func (r ApiGetAllTrayRequest) RackName(rackName string) ApiGetAllTrayRequest {
	r.rackName = &rackName
	return r
}

// Filter by tray type
func (r ApiGetAllTrayRequest) Type_(type_ string) ApiGetAllTrayRequest {
	r.type_ = &type_
	return r
}

// Filter by component ID. Can be specified multiple times to filter on more than one component ID. Requires &#39;type&#39; parameter.
func (r ApiGetAllTrayRequest) ComponentId(componentId string) ApiGetAllTrayRequest {
	r.componentId = &componentId
	return r
}

// Filter by tray UUID. Can be specified multiple times to filter on more than one tray ID.
func (r ApiGetAllTrayRequest) Id(id string) ApiGetAllTrayRequest {
	r.id = &id
	return r
}

// Page number for pagination query
func (r ApiGetAllTrayRequest) PageNumber(pageNumber int32) ApiGetAllTrayRequest {
	r.pageNumber = &pageNumber
	return r
}

// Page size for pagination query
func (r ApiGetAllTrayRequest) PageSize(pageSize int32) ApiGetAllTrayRequest {
	r.pageSize = &pageSize
	return r
}

// Ordering for pagination query
func (r ApiGetAllTrayRequest) OrderBy(orderBy string) ApiGetAllTrayRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiGetAllTrayRequest) Execute() ([]Tray, *http.Response, error) {
	return r.ApiService.GetAllTrayExecute(r)
}

/*
GetAllTray Retrieve all Trays

Get all Trays (components) for the specified Site.

Org must have an Infrastructure Provider entity. User must have `FORGE_PROVIDER_ADMIN` authorization role.

**Filter constraints:**
- `rackId` and `rackName` are mutually exclusive
- `rackId`/`rackName` cannot be combined with `id`/`componentId` (rack-level vs component-level targeting)
- `componentId` requires `type` to be specified

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @return ApiGetAllTrayRequest
*/
func (a *TrayAPIService) GetAllTray(ctx context.Context, org string) ApiGetAllTrayRequest {
	return ApiGetAllTrayRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
	}
}

// Execute executes the request
//  @return []Tray
func (a *TrayAPIService) GetAllTrayExecute(r ApiGetAllTrayRequest) ([]Tray, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Tray
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TrayAPIService.GetAllTray")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/tray"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.siteId == nil {
		return localVarReturnValue, nil, reportError("siteId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "siteId", r.siteId, "form", "")
	if r.rackId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rackId", r.rackId, "form", "")
	}
	if r.rackName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rackName", r.rackName, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.componentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "componentId", r.componentId, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.pageNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageNumber", r.pageNumber, "form", "")
	} else {
		var defaultValue int32 = 1
		r.pageNumber = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "orderBy", r.orderBy, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTrayRequest struct {
	ctx context.Context
	ApiService *TrayAPIService
	siteId *string
	org string
	id string
}

// ID of the Site
func (r ApiGetTrayRequest) SiteId(siteId string) ApiGetTrayRequest {
	r.siteId = &siteId
	return r
}

func (r ApiGetTrayRequest) Execute() (*Tray, *http.Response, error) {
	return r.ApiService.GetTrayExecute(r)
}

/*
GetTray Retrieve a Tray

Get a Tray by ID.

Org must have an Infrastructure Provider entity. User must have `FORGE_PROVIDER_ADMIN` authorization role.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param org Name of the Org
 @param id ID of the Tray
 @return ApiGetTrayRequest
*/
func (a *TrayAPIService) GetTray(ctx context.Context, org string, id string) ApiGetTrayRequest {
	return ApiGetTrayRequest{
		ApiService: a,
		ctx: ctx,
		org: org,
		id: id,
	}
}

// Execute executes the request
//  @return Tray
func (a *TrayAPIService) GetTrayExecute(r ApiGetTrayRequest) (*Tray, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Tray
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TrayAPIService.GetTray")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/org/{org}/carbide/tray/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"org"+"}", url.PathEscape(parameterValueToString(r.org, "org")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.siteId == nil {
		return localVarReturnValue, nil, reportError("siteId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "siteId", r.siteId, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v CarbideAPIError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
